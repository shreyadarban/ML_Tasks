# -*- coding: utf-8 -*-
"""Task2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DaVJNArWKZrE4-3h1g7hV8cEjqSVz_8n
"""

!pip install scikit-surprise

import pandas as pd
from surprise import Dataset, Reader, KNNBasic
from surprise.model_selection import train_test_split
from surprise import accuracy

import pandas as pd

# Load the dataset
data = pd.read_csv('/movies1.csv')

# Exploratory Data Analysis (EDA)
# Display the first few rows of the dataset as a table
print("First few rows of the dataset:")
display(data.head())

# Display summary information about the dataset
print("\nSummary information about the dataset:")
data_info = data.info()

# If data.info() returns None, it means there was an issue with reading the dataset
if data_info is not None:
    # Convert the summary information to a DataFrame for better presentation
    data_info_df = pd.DataFrame({'Column Name': data.columns, 'Data Type': data.dtypes})
    display(data_info_df)
else:
    print("There was an issue with reading the dataset.")

# Model Building
# Define the Reader object
reader = Reader(rating_scale=(1, 5))

# Load the dataset into Surprise format
data_surprise = Dataset.load_from_df(data[['id', 'title', 'vote_average']], reader)

# Split the dataset into training and testing sets
trainset, testset = train_test_split(data_surprise, test_size=0.2, random_state=42)

# Train the model using the KNNBasic algorithm
model = KNNBasic(sim_options={'user_based': True})  # User-based collaborative filtering
model.fit(trainset)

#Model Evaluation
# Make predictions on the test set
predictions = model.test(testset)

# Evaluate the model
accuracy.rmse(predictions)

# Step 6: Recommendation Generation
# Recommend movies for a given user (replace 'user_id' with the desired user ID)
user_id = 1

# Get list of all movie ids
all_movie_ids = data['id'].unique()

# Get list of movie ids rated by the user
user_rated_movie_ids = data[data['id'] == user_id]['id']

# Get list of movie ids not rated by the user
unrated_movie_ids = set(all_movie_ids) - set(user_rated_movie_ids)

# Get predictions for unrated movies
recommended_movies = []
for movie_id in unrated_movie_ids:
    predicted_rating = model.predict(user_id, movie_id).est
    recommended_movies.append((movie_id, predicted_rating))

# Sort recommended movies by predicted rating
recommended_movies.sort(key=lambda x: x[1], reverse=True)

# Print top recommended movies
top_n = 5
print(f"Top {top_n} recommended movies for user {user_id}:")
for movie_id, predicted_rating in recommended_movies[:top_n]:
    movie_title = data[data['id'] == movie_id]['title'].iloc[0]  # Assuming 'title' column exists
    print(f"{movie_title} (Predicted Rating: {predicted_rating:.2f})")

import matplotlib.pyplot as plt

# Extract movie titles and predicted ratings for top recommended movies
top_movie_titles = [data[data['id'] == movie_id]['title'].iloc[0] for movie_id, _ in recommended_movies[:top_n]]
predicted_ratings = [predicted_rating for _, predicted_rating in recommended_movies[:top_n]]

# Create a bar plot
plt.figure(figsize=(10, 6))
plt.barh(top_movie_titles, predicted_ratings, color='skyblue')
plt.xlabel('Predicted Rating')
plt.ylabel('Movie Title')
plt.title(f'Top {top_n} Recommended Movies for User {user_id}')
plt.gca().invert_yaxis()  # Invert y-axis to display top-rated movie at the top
plt.show()

